package experiments;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.coode.distance.Distance;
import org.coode.distance.owl.AbstractAxiomBasedDistance;
import org.coode.distance.wrapping.DistanceTableObject;
import org.coode.oppl.Variable;
import org.coode.oppl.bindingtree.AssignmentMap;
import org.coode.owl.generalise.OWLAxiomInstantiation;
import org.coode.proximitymatrix.ClusteringProximityMatrix;
import org.coode.proximitymatrix.cluster.Cluster;
import org.coode.proximitymatrix.cluster.ClusterDecompositionModel;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLEntity;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.util.DLExpressivityChecker;
import org.semanticweb.owlapi.util.MultiMap;

import uk.ac.manchester.cs.owl.owlapi.mansyntaxrenderer.ManchesterOWLSyntaxOWLObjectRendererImpl;

public class ClusterResultsExploitationUtils {
    public static <P extends OWLEntity> void printHighAbstractionStats(
            ClusterDecompositionModel<P> fineGrainedModel,
            ClusterDecompositionModel<P> model, PrintStream output,
            PrintStream multioutput, String ontologyName) {
        String[][] genStatsTable = new String[2][7];
        for (int i = 0; i < genStatsTable.length; i++) {
            Arrays.fill(genStatsTable[i], "");
        }
        String[][] highGenStatsTable = new String[model.getClusterList().size() + 1][6];
        for (int i = 0; i < highGenStatsTable.length; i++) {
            Arrays.fill(highGenStatsTable[i], "");
        }
        // Stats that go to the universal file
        int noOfHighGeneralisations = 0;
        int totalNoOfHighGeneralisations = 0;
        int noOfGeneralInstantiations = 0;
        int totalNoOfGeneralInstantiations = 0;
        int noOfLowInstantiations = 0;
        int totalNoOfLowInstantiations = 0;
        // table with generalisation details
        output.println("clusterNo\t clusterID\t #Entities\t #HighGeneralisations\t "
                + "#GeneralInstansiations\t " + "#LowInstansiations\t "
                + "#MeanGenInstansiations/HighGen\t #MeanInst/HighGen");
        // set for keeping all the high generalisations excluding duplicates
        Set<OWLAxiom> allHighGeneralisations = new HashSet<OWLAxiom>();
        Set<OWLAxiomInstantiation> allGenInstantiations = new HashSet<OWLAxiomInstantiation>();
        Set<OWLAxiomInstantiation> allLowInstantiations = new HashSet<OWLAxiomInstantiation>();
        List<Cluster<P>> clusterList = model.getClusterList();
        String[][] table = new String[clusterList.size()][8];
        for (int j = 0; j < table.length; j++) {
            Arrays.fill(table[j], "");
        }
        for (int i = 0; i < clusterList.size(); i++) {
            noOfHighGeneralisations = 0;
            noOfGeneralInstantiations = 0;
            noOfLowInstantiations = 0;
            MultiMap<OWLAxiom, OWLAxiomInstantiation> highGeneralisationMultiMap = model
                    .get(clusterList.get(i));
            MultiMap<OWLAxiom, OWLAxiomInstantiation> lowGeneralisationMultiMap = fineGrainedModel
                    .get(clusterList.get(i));
            if (highGeneralisationMultiMap != null && lowGeneralisationMultiMap != null
                    && lowGeneralisationMultiMap.size() > 0) {
                Set<OWLAxiom> keySet = highGeneralisationMultiMap.keySet();
                noOfHighGeneralisations = keySet.size();
                totalNoOfHighGeneralisations += noOfHighGeneralisations;
                // count all high generalisations
                allHighGeneralisations.addAll(keySet);
                for (OWLAxiom genax : keySet) {
                    Collection<OWLAxiomInstantiation> genInstantiations = highGeneralisationMultiMap
                            .get(genax);
                    allGenInstantiations.addAll(genInstantiations);
                    noOfGeneralInstantiations = genInstantiations.size();
                    totalNoOfGeneralInstantiations += noOfGeneralInstantiations;
                    for (OWLAxiomInstantiation geninst : genInstantiations) {
                        Collection<OWLAxiomInstantiation> lowInstantiations = lowGeneralisationMultiMap
                                .get(geninst.getAxiom());
                        if (lowInstantiations != null && lowInstantiations.size() > 0) {
                            allLowInstantiations.addAll(lowInstantiations);
                            noOfLowInstantiations = lowInstantiations.size();
                            totalNoOfLowInstantiations += noOfLowInstantiations;
                        }
                    }
                }
                // fill table with metrics for every cluster
                table[i][0] = Integer.toString(i);
                Variable<?> variableRepresentative = fineGrainedModel
                        .getVariableRepresentative(clusterList.get(i));
                if (variableRepresentative == null) {
                    table[i][1] = "null_representative";
                } else {
                    table[i][1] = variableRepresentative.toString();
                }
                table[i][2] = Integer.toString(clusterList.get(i).size());
                table[i][3] = Integer.toString(noOfHighGeneralisations);
                table[i][4] = Integer.toString(noOfGeneralInstantiations);
                table[i][5] = Integer.toString(noOfLowInstantiations);
                if (noOfHighGeneralisations != 0) {
                    table[i][6] = Double.toString((double) noOfGeneralInstantiations
                            / noOfHighGeneralisations);
                    table[i][7] = Double.toString((double) noOfLowInstantiations
                            / noOfHighGeneralisations);
                } else {
                    table[i][6] = Integer.toString(0);
                    table[i][7] = Integer.toString(0);
                }
            }
        }
        print(output, table);
        // print the generic output in csv format
        // multioutput.println("Ontology, #Clusters, #HighGens, "
        // + "#GenInstantiations, #Instantiations, "
        // + "#MeanGenInstansiations/HighGen, #MeanInst/HighGen");
        // Ontology #Clusters #HighGens #GenInstantiations
        // #Instantiations #MeanGenInstansiations/HighGen #MeanInst/HighGen
        double meanGenInstPerHighGen = totalNoOfHighGeneralisations == 0 ? 0
                : (double) totalNoOfGeneralInstantiations / totalNoOfHighGeneralisations;
        double meanLowInstPerHighGen = totalNoOfHighGeneralisations == 0 ? 0
                : (double) totalNoOfLowInstantiations / totalNoOfHighGeneralisations;
        multioutput.println(ontologyName + "," + clusterList.size() + ","
                + allHighGeneralisations.size() + "," + allGenInstantiations.size() + ","
                + allLowInstantiations.size() + "," + meanGenInstPerHighGen + ","
                + meanLowInstPerHighGen);
    }

    public static <P extends OWLEntity> void printHighGeneralisations(
            ClusterDecompositionModel<P> fineGrainedModel,
            ClusterDecompositionModel<P> model, PrintStream output) {
        output.println("ClusterNo\t ClusterID\t Cluster\t Generalizations\t GenInstantiations\t Instantiations");
        List<Cluster<P>> clusterList = model.getClusterList();
        for (int i = 0; i < clusterList.size(); i++) {
            MultiMap<OWLAxiom, OWLAxiomInstantiation> highGenMultiMap = model
                    .get(clusterList.get(i));
            MultiMap<OWLAxiom, OWLAxiomInstantiation> lowGenMultiMap = fineGrainedModel
                    .get(clusterList.get(i));
            Map<OWLAxiom, MultiMap<OWLAxiomInstantiation, OWLAxiomInstantiation>> finalMap = new LinkedHashMap<OWLAxiom, MultiMap<OWLAxiomInstantiation, OWLAxiomInstantiation>>();
            // create the complex map for everything
            // XXX: this needs to be on a separate model
            if (highGenMultiMap != null && fineGrainedModel != null) {
                int tableSize = 0;
                Set<OWLAxiom> keySet = highGenMultiMap.keySet();
                for (OWLAxiom generalisation : keySet) {
                    Collection<OWLAxiomInstantiation> collection = highGenMultiMap
                            .get(generalisation);
                    if (collection.size() > 1) {
                        MultiMap<OWLAxiomInstantiation, OWLAxiomInstantiation> map = new MultiMap<OWLAxiomInstantiation, OWLAxiomInstantiation>();
                        for (OWLAxiomInstantiation genInst : collection) {
                            Collection<OWLAxiomInstantiation> instantiations = lowGenMultiMap
                                    .get(genInst.getAxiom());
                            if (instantiations != null && instantiations.size() > 0) {
                                map.putAll(genInst, instantiations);
                                tableSize += instantiations.size();
                            }
                        }
                        finalMap.put(generalisation, map);
                    }
                }
                // create the table and print it
                if (finalMap != null && finalMap.size() > 0) {
                    String[][] table = new String[tableSize + 1][6];
                    for (int j = 0; j < table.length; j++) {
                        Arrays.fill(table[j], "");
                    }
                    table[0][0] = Integer.toString(i);
                    Variable<?> variableRepresentative = model
                            .getVariableRepresentative(clusterList.get(i));
                    if (variableRepresentative == null) {
                        table[0][1] = "null_representative";
                    } else {
                        table[0][1] = variableRepresentative.toString();
                    }
                    table[0][2] = clusterList.get(i).toString();
                    int rowIndex = 0;
                    for (OWLAxiom gen : finalMap.keySet()) {
                        table[rowIndex][3] = gen.toString();
                        MultiMap<OWLAxiomInstantiation, OWLAxiomInstantiation> multiMap = finalMap
                                .get(gen);
                        if (multiMap != null && multiMap.size() > 0) {
                            for (OWLAxiomInstantiation geninst : multiMap.keySet()) {
                                Collection<OWLAxiomInstantiation> collection = multiMap
                                        .get(geninst);
                                table[rowIndex][4] = geninst.toString();
                                for (OWLAxiomInstantiation inst : multiMap.get(geninst)) {
                                    table[rowIndex][5] = inst.toString();
                                    rowIndex++;
                                }
                            }
                        }
                    }
                    print(output, table);
                }
            }
        }
    }

    public static <P extends OWLEntity> void printGeneralisationStats(
            ClusterDecompositionModel<P> model, PrintStream output, String filename) {
        // general stats
        Set<OWLAxiom> totalGens = new HashSet<OWLAxiom>();
        Set<OWLAxiomInstantiation> totalInstans = new HashSet<OWLAxiomInstantiation>();
        double totalAvgClusterCoverage = 0;
        int totalClusterSize = 0;
        List<Cluster<P>> clusterList = model.getClusterList();
        for (int i = 1; i < clusterList.size(); i++) {
            double avgClusterCoverage = 0;
            final MultiMap<OWLAxiom, OWLAxiomInstantiation> multiMap = model
                    .get(clusterList.get(i));
            totalGens.addAll(multiMap.keySet());
            totalInstans.addAll(multiMap.getAllValues());
            totalClusterSize += clusterList.get(i).size();
            double clusterCoverage = 0;
            int gensNo = multiMap.keySet().size();
            // int fullGens = 0;
            // int singetonGens = 0;
            // int instNo = 0;
            for (OWLAxiom gen : multiMap.keySet()) {
                // instNo += multiMap.get(gen).size();
                // if (multiMap.get(gen).size() == 1) {
                // singetonGens++;
                // }
                OWLAxiomInstantiation instantiation = multiMap.get(gen).iterator().next();
                AssignmentMap substitutions = instantiation.getSubstitutions();
                Set<Variable<?>> variables = substitutions.keySet();
                for (Variable<?> var : variables) {
                    if (clusterList.get(i).containsAll(substitutions.get(var))) {
                        clusterCoverage += substitutions.get(var).size()
                                / clusterList.get(i).size();
                        // if (clusterList.get(i).size() ==
                        // substitutions.get(var).size()) {
                        // fullGens++;
                        // }
                    }
                }
            }
            avgClusterCoverage = clusterCoverage / gensNo;
            totalAvgClusterCoverage += avgClusterCoverage;
        }
        int ontologyNo = 0;
        int axiomCount = 0;
        int logicAxiomCount = 0;
        int signatureSize = 0;
        DLExpressivityChecker dlExpressivityChecker = new DLExpressivityChecker(
                model.getOntologies());
        String dlExpressivity = dlExpressivityChecker.getDescriptionLogicName();
        // String dlExpressivity = "-";
        for (OWLOntology o : model.getOntologies()) {
            ontologyNo++;
            axiomCount += o.getAxiomCount();
            logicAxiomCount += o.getLogicalAxiomCount();
            signatureSize += o.getSignature().size();
        }
        output.println("Ontology, DLExpressivity, #Ontologies, #Axioms, #LogicAxioms, "
                + "#Clusters, #Entities, #ClusteredEntities, AvgClusterSize, #TotalGens, "
                + "#TotalInst, AvgGensPerCluster, AvgInstPerCluster, AvgTotalClusterCoveragePerGen");
        output.println(filename + "," + dlExpressivity + ","
                + Integer.toString(ontologyNo) + "," + Integer.toString(axiomCount) + ","
                + Integer.toString(logicAxiomCount) + ","
                + Integer.toString(clusterList.size()) + ","
                + Integer.toString(signatureSize) + ","
                + Integer.toString(totalClusterSize) + ","
                + Double.toString(totalClusterSize / clusterList.size()) + ","
                + Integer.toString(totalGens.size()) + ","
                + Integer.toString(totalInstans.size()) + ","
                + Double.toString(totalGens.size() / clusterList.size()) + ","
                + Double.toString(totalInstans.size() / clusterList.size()) + ","
                + Double.toString(totalAvgClusterCoverage));
    }

    public static <P extends OWLEntity> void filterResults(
            ClusteringProximityMatrix<DistanceTableObject<OWLEntity>> clusteringMatrix,
            ClusterDecompositionModel<OWLEntity> model, Distance<OWLEntity> distance,
            PrintStream output) {
        ManchesterOWLSyntaxOWLObjectRendererImpl renderer = new ManchesterOWLSyntaxOWLObjectRendererImpl();
        // general stats
        Set<OWLAxiom> totalGens = new HashSet<OWLAxiom>();
        Set<OWLAxiomInstantiation> totalInstans = new HashSet<OWLAxiomInstantiation>();
        double totalAvgClusterCoverage = 0;
        int totalClusterSize = 0;
        String[][] clusterStats = new String[model.getClusterList().size() + 1][8];
        for (int i = 0; i < clusterStats.length; i++) {
            Arrays.fill(clusterStats[i], "");
        }
        clusterStats[0][0] = "clusterID";
        clusterStats[0][1] = "clusterSize";
        clusterStats[0][2] = "#Gens";
        clusterStats[0][3] = "#fulGens";
        clusterStats[0][4] = "#singletonGens";
        clusterStats[0][5] = "#Instansiations";
        clusterStats[0][6] = "#AngInst/Gen";
        clusterStats[0][7] = "#AvgClusterCoverage/Gen";
        List<Cluster<OWLEntity>> clusterList = model.getClusterList();
        for (int i = 1; i < clusterList.size(); i++) {
            clusterStats[i][0] = Integer.toString(i);
            double avgClusterCoverage = 0;
            final MultiMap<OWLAxiom, OWLAxiomInstantiation> multiMap = model
                    .get(clusterList.get(i));
            totalGens.addAll(multiMap.keySet());
            totalInstans.addAll(multiMap.getAllValues());
            clusterStats[i][1] = Integer.toString(clusterList.get(i).size());
            totalClusterSize += clusterList.get(i).size();
            double clusterCoverage = 0;
            int gensNo = multiMap.keySet().size();
            clusterStats[i][2] = Integer.toString(gensNo);
            int fullGens = 0;
            int singetonGens = 0;
            int instNo = 0;
            for (OWLAxiom gen : multiMap.keySet()) {
                instNo += multiMap.get(gen).size();
                if (multiMap.get(gen).size() == 1) {
                    singetonGens++;
                }
                OWLAxiomInstantiation instantiation = multiMap.get(gen).iterator().next();
                AssignmentMap substitutions = instantiation.getSubstitutions();
                Set<Variable<?>> variables = substitutions.keySet();
                for (Variable<?> var : variables) {
                    if (clusterList.get(i).containsAll(substitutions.get(var))) {
                        clusterCoverage += substitutions.get(var).size()
                                / clusterList.get(i).size();
                        if (clusterList.get(i).size() == substitutions.get(var).size()) {
                            fullGens++;
                        }
                    }
                }
            }
            clusterStats[i][3] = Integer.toString(fullGens);
            clusterStats[i][4] = Integer.toString(singetonGens);
            clusterStats[i][5] = Integer.toString(instNo);
            if (gensNo != 0) {
                clusterStats[i][6] = Double.toString((double) instNo / gensNo);
                avgClusterCoverage = clusterCoverage / gensNo;
            } else {
                clusterStats[i][6] = Double.toString(0);
                avgClusterCoverage = 0;
            }
            totalAvgClusterCoverage += avgClusterCoverage;
            clusterStats[i][7] = Double.toString(avgClusterCoverage);
        }
        // cluster stats
        // double avgClusterSize = (double) totalClusterSize /
        // clusterList.size();
        int ontologyNo = 0;
        int axiomCount = 0;
        int logicAxiomCount = 0;
        int signatureSize = 0;
        int classNo = 0;
        // DLExpressivityChecker dlExpressivityChecker = new
        // DLExpressivityChecker(model.getOntologies());
        // String dlExpressivity =
        // dlExpressivityChecker.getDescriptionLogicName();
        String dlExpressivity = "-";
        for (OWLOntology o : model.getOntologies()) {
            ontologyNo++;
            axiomCount += o.getAxiomCount();
            logicAxiomCount += o.getLogicalAxiomCount();
            signatureSize += o.getSignature().size();
            classNo += o.getClassesInSignature().size();
        }
        String[][] generalStats = new String[2][13];
        for (int i = 0; i < generalStats.length; i++) {
            Arrays.fill(generalStats[i], "");
        }
        generalStats[0][0] = "DLExpressivity";
        generalStats[0][1] = "#Ontologies";
        generalStats[0][2] = "#Axioms";
        generalStats[0][3] = "#LogicAxioms";
        generalStats[0][4] = "#Entities";
        generalStats[0][5] = "#Classes";
        generalStats[0][6] = "#ClusteredEntities";
        generalStats[0][7] = "AvgClusterSize";
        generalStats[0][8] = "#TotalGens";
        generalStats[0][9] = "#TotalInst";
        generalStats[0][10] = "AvgGensPerCluster";
        generalStats[0][11] = "AvgInstPerCluster";
        generalStats[0][12] = "AvgTotalClusterCoverage/Gen";
        generalStats[1][0] = dlExpressivity;
        generalStats[1][1] = Integer.toString(ontologyNo);
        generalStats[1][2] = Integer.toString(axiomCount);
        generalStats[1][3] = Integer.toString(logicAxiomCount);
        generalStats[1][4] = Integer.toString(signatureSize);
        generalStats[1][5] = Integer.toString(classNo);
        generalStats[1][6] = Integer.toString(totalClusterSize);
        generalStats[1][7] = Double.toString(totalClusterSize / clusterList.size());
        generalStats[1][8] = Integer.toString(totalGens.size());
        generalStats[1][9] = Integer.toString(totalInstans.size());
        generalStats[1][10] = Double.toString(totalGens.size() / clusterList.size());
        generalStats[1][11] = Double.toString(totalInstans.size() / clusterList.size());
        generalStats[1][12] = Double.toString(totalAvgClusterCoverage
                / clusterList.size());
        print(output, generalStats);
        output.println();
        print(output, clusterStats);
        output.println();
        // Table A
        output.println("ClusterID\t Cluster\t Generalizations\t Instantiations");
        for (Cluster<OWLEntity> c : model.getClusterList()) {
            final MultiMap<OWLAxiom, OWLAxiomInstantiation> multiMap = model.get(c);
            String[][] table = new String[multiMap.size()][4];
            if (multiMap.size() > 0) {
                for (int i = 0; i < table.length; i++) {
                    Arrays.fill(table[i], "");
                }
                Variable<?> variableRepresentative = model.getVariableRepresentative(c);
                if (variableRepresentative == null) {
                    table[0][0] = "null_representative";
                } else {
                    table[0][0] = variableRepresentative.toString();
                }
                table[0][1] = c.toString();
                int rowIndex = 0;
                for (OWLAxiom gen : multiMap.keySet()) {
                    table[rowIndex][2] = renderer.render(gen);
                    for (OWLAxiomInstantiation inst : multiMap.get(gen)) {
                        table[rowIndex][3] = renderer.render(inst.getAxiom()) + " "
                                + inst.getSubstitutions();
                        rowIndex++;
                    }
                }
                print(output, table);
            }
        }
        // Table B
        output.println("ClusterID\t Cluster\t Distance Axioms");
        for (Cluster<OWLEntity> c : model.getClusterList()) {
            OWLEntity clusterRepresentative = c.iterator().next();
            Collection<OWLAxiom> axioms = ((AbstractAxiomBasedDistance) distance)
                    .getAxioms(clusterRepresentative);
            String[][] table = new String[axioms.size()][3];
            for (int i = 0; i < table.length; i++) {
                Arrays.fill(table[i], "");
            }
            Variable<?> variableRepresentative = model.getVariableRepresentative(c);
            if (variableRepresentative == null) {
                table[0][0] = "null_representative";
            } else {
                table[0][0] = variableRepresentative.getName();
            }
            table[0][1] = c.toString();
            int rowIndex = 0;
            for (OWLAxiom ax : axioms) {
                table[rowIndex][2] = renderer.render(ax).replaceAll("\n", " ");
                rowIndex++;
            }
            print(output, table);
        }
        // Table C
        output.println("ClusterID\t Cluster (C)\tClosest Entities (E)\tC /\\ E\tC \\ E\tE \\ C");
        for (Cluster<OWLEntity> c : model.getClusterList()) {
            findClosestClusters(clusteringMatrix, (AbstractAxiomBasedDistance) distance,
                    c, output, renderer);
        }
    }

    public static void print(PrintStream output, String[][] table) {
        for (int i = 0; i < table.length; i++) {
            for (int j = 0; j < table[i].length; j++) {
                output.print(table[i][j].replaceAll("\n", " "));
                output.print('\t');
            }
            output.println();
        }
        // empty line to separate clusters
        output.println();
    }

    private static void findClosestClusters(
            ClusteringProximityMatrix<DistanceTableObject<OWLEntity>> clusteringMatrix,
            AbstractAxiomBasedDistance distance, Cluster<? extends OWLEntity> cluster,
            PrintStream output, ManchesterOWLSyntaxOWLObjectRendererImpl renderer) {
        Collection<Collection<? extends DistanceTableObject<OWLEntity>>> objects = clusteringMatrix
                .getObjects();
        Collection<? extends DistanceTableObject<OWLEntity>> found = null;
        for (Collection<? extends DistanceTableObject<OWLEntity>> collection : objects) {
            for (DistanceTableObject<OWLEntity> object : collection) {
                if (cluster.contains(object.getObject())) {
                    found = collection;
                }
            }
        }
        if (found != null) {
            DistanceTableObject<OWLEntity> next = found.iterator().next();
            OWLEntity clusterEntity = next.getObject();
            Collection<OWLAxiom> axiomsObj = distance.getAxioms(clusterEntity);
            Map<Collection<? extends DistanceTableObject<OWLEntity>>, Double> distanceMap = new HashMap<Collection<? extends DistanceTableObject<OWLEntity>>, Double>();
            for (Collection<? extends DistanceTableObject<OWLEntity>> anotherObject : objects) {
                if (clusteringMatrix.getDistance(found, anotherObject) < 1
                        && clusteringMatrix.getDistance(found, anotherObject) > 0) {
                    distanceMap.put(anotherObject,
                            clusteringMatrix.getDistance(found, anotherObject));
                }
            }
            List<OWLEntity> sortedDistanceSet = entriesSortedByValues(distanceMap);
            int counter = 0;
            List<List<Set<OWLAxiom>>> allDiffs = new ArrayList<List<Set<OWLAxiom>>>();
            for (OWLEntity b : sortedDistanceSet) {
                List<Set<OWLAxiom>> diffs = findAxiomDifferences(distance, axiomsObj, b);
                allDiffs.add(diffs);
                int max = Math.max(diffs.get(0).size(),
                        Math.max(diffs.get(1).size(), diffs.get(2).size()));
                counter += max;
            }
            String[][] table = new String[counter][5];
            for (int i = 0; i < table.length; i++) {
                Arrays.fill(table[i], "");
            }
            table[0][0] = cluster.toString();
            int rowIndex = 0;
            for (int i = 0; i < sortedDistanceSet.size(); i++) {
                table[rowIndex][1] = sortedDistanceSet.get(i).toString();
                List<Set<OWLAxiom>> diffs = allDiffs.get(i);
                int max = Math.max(diffs.get(0).size(),
                        Math.max(diffs.get(1).size(), diffs.get(2).size()));
                int internalCounter = 0;
                for (OWLAxiom ax : diffs.get(0)) {
                    table[rowIndex + internalCounter][2] = renderer.render(ax);
                    internalCounter++;
                }
                internalCounter = 0;
                for (OWLAxiom ax : diffs.get(1)) {
                    table[rowIndex + internalCounter][3] = renderer.render(ax);
                    internalCounter++;
                }
                internalCounter = 0;
                for (OWLAxiom ax : diffs.get(2)) {
                    table[rowIndex + internalCounter][4] = renderer.render(ax);
                    internalCounter++;
                }
                rowIndex += max;
            }
            print(output, table);
        }
    }

    private static Set<OWLAxiom> intersect(Collection<OWLAxiom> s1,
            Collection<OWLAxiom> s2) {
        Set<OWLAxiom> toReturn = new HashSet<OWLAxiom>(s1);
        toReturn.retainAll(s2);
        return toReturn;
    }

    private static Set<OWLAxiom> diff(Collection<OWLAxiom> s1, Collection<OWLAxiom> s2) {
        Set<OWLAxiom> toReturn = new HashSet<OWLAxiom>(s1);
        toReturn.removeAll(s2);
        return toReturn;
    }

    private static List<Set<OWLAxiom>> findAxiomDifferences(
            AbstractAxiomBasedDistance distance, Collection<OWLAxiom> c, OWLEntity b) {
        List<Set<OWLAxiom>> toReturn = new ArrayList<Set<OWLAxiom>>();
        Collection<OWLAxiom> e = distance.getAxioms(b);
        toReturn.add(intersect(e, c));
        toReturn.add(diff(c, e));
        toReturn.add(diff(e, c));
        return toReturn;
    }

    private static List<OWLEntity> entriesSortedByValues(
            Map<Collection<? extends DistanceTableObject<OWLEntity>>, Double> map) {
        SortedSet<Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double>> sortedEntries = new TreeSet<Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double>>(
                new Comparator<Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double>>() {
                    @Override
                    public
                            int
                            compare(Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double> e1,
                                    Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double> e2) {
                        return e1.getValue().compareTo(e2.getValue());
                    }
                });
        sortedEntries.addAll(map.entrySet());
        List<OWLEntity> toReturn = new ArrayList<OWLEntity>();
        for (Map.Entry<Collection<? extends DistanceTableObject<OWLEntity>>, Double> e : sortedEntries) {
            for (DistanceTableObject<OWLEntity> dt : e.getKey()) {
                toReturn.add(dt.getObject());
            }
        }
        return toReturn;
    }
}
